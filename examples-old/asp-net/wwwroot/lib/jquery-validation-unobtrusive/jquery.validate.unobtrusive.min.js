/* eslint-disable no-useless-escape */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable no-unused-vars */
// Unobtrusive validation support library for jQuery and jQuery Validate
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// @version v3.2.11
!((a) => {
  "function" === typeof define && define.amd
    ? define("jquery.validate.unobtrusive", ["jquery-validation"], a)
    : "object" === typeof module && module.exports
      ? (module.exports = a(require("jquery-validation")))
      : (jQuery.validator.unobtrusive = a(jQuery));
})((a) => {
  function e(a, e, n) {
    (a.rules[e] = n), a.message && (a.messages[e] = a.message);
  }

  function n(a) {
    return a.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/g);
  }

  function t(a) {
    return a.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, "\\$1");
  }

  function r(a) {
    return a.substr(0, a.lastIndexOf(".") + 1);
  }

  function i(a, e) {
    return 0 === a.indexOf("*.") && (a = a.replace("*.", e)), a;
  }

  function o(e, n) {
    const r = a(this).find(`[data-valmsg-for='${t(n[0].name)}']`);
    const i = r.attr("data-valmsg-replace");
    const o = i ? a.parseJSON(i) !== !1 : null;
    r.removeClass("field-validation-valid").addClass("field-validation-error"),
      e.data("unobtrusiveContainer", r),
      o
        ? (r.empty(), e.removeClass("input-validation-error").appendTo(r))
        : e.hide();
  }

  function d(e, n) {
    const t = a(this).find("[data-valmsg-summary=true]");
    const r = t.find("ul");
    r?.length &&
      n.errorList.length &&
      (r.empty(),
      t
        .addClass("validation-summary-errors")
        .removeClass("validation-summary-valid"),
      a.each(n.errorList, function () {
        a("<li />").html(this.message).appendTo(r);
      }));
  }

  function s(e) {
    const n = e.data("unobtrusiveContainer");

    if (n) {
      const t = n.attr("data-valmsg-replace");
      const r = t ? a.parseJSON(t) : null;
      n
        .addClass("field-validation-valid")
        .removeClass("field-validation-error"),
        e.removeData("unobtrusiveContainer"),
        r && n.empty();
    }
  }

  function l(e) {
    const n = a(this);
    const t = "__jquery_unobtrusive_validation_form_reset";

    if (!n.data(t)) {
      n.data(t, !0);

      try {
        n.data("validator").resetForm();
      } finally {
        n.removeData(t);
      }

      n
        .find(".validation-summary-errors")
        .addClass("validation-summary-valid")
        .removeClass("validation-summary-errors"),
        n
          .find(".field-validation-error")
          .addClass("field-validation-valid")
          .removeClass("field-validation-error")
          .removeData("unobtrusiveContainer")
          .find(">*")
          .removeData("unobtrusiveContainer");
    }
  }

  function u(e) {
    const n = a(e);
    let t = n.data(v);
    const r = a.proxy(l, e);
    const i = f.unobtrusive.options || {};
    const u = (n, t) => {
      const r = i[n];
      r && a.isFunction(r) && r.apply(e, t);
    };

    return (
      t ||
        ((t = {
          options: {
            errorClass: i.errorClass || "input-validation-error",
            errorElement: i.errorElement || "span",
            errorPlacement: () => {
              o.apply(e, arguments), u("errorPlacement", arguments);
            },
            invalidHandler: () => {
              d.apply(e, arguments), u("invalidHandler", arguments);
            },
            messages: {},
            rules: {},
            success: () => {
              s.apply(e, arguments), u("success", arguments);
            },
          },
          attachValidation: function () {
            n.off(`reset.${v}`, r).on(`reset.${v}`, r).validate(this.options);
          },
          validate: () => (n.validate(), n.valid()),
        }),
        n.data(v, t)),
      t
    );
  }

  let m;
  const f = a.validator;
  const v = "unobtrusiveValidation";

  return (
    (f.unobtrusive = {
      adapters: [],
      parseElement: function (e, n) {
        let t;
        let r;
        let i;
        const o = a(e);
        const d = o.parents("form")[0];
        d &&
          ((t = u(d)),
          (t.options.rules[e.name] = r = {}),
          (t.options.messages[e.name] = i = {}),
          a.each(this.adapters, function () {
            let n = `data-val-${this.name}`;
            const t = o.attr(n);
            const s = {};
            void 0 !== t &&
              ((n += "-"),
              a.each(this.params, function () {
                s[this] = o.attr(n + this);
              }),
              this.adapt({
                element: e,
                form: d,
                message: t,
                params: s,
                rules: r,
                messages: i,
              }));
          }),
          a.extend(r, { __dummy__: !0 }),
          n || t.attachValidation());
      },
      parse: (e) => {
        const n = a(e);
        const t = n
          .parents()
          .addBack()
          .filter("form")
          .add(n.find("form"))
          .has("[data-val=true]");
        n.find("[data-val=true]").each(function () {
          f.unobtrusive.parseElement(this, !0);
        }),
          t.each(function () {
            const a = u(this);
            a?.attachValidation();
          });
      },
    }),
    (m = f.unobtrusive.adapters),
    (m.add = function (a, e, n) {
      return (
        n || ((n = e), (e = [])),
        this.push({ name: a, params: e, adapt: n }),
        this
      );
    }),
    (m.addBool = function (a, n) {
      return this.add(a, (t) => {
        e(t, n || a, !0);
      });
    }),
    (m.addMinMax = function (a, n, t, r, i, o) {
      return this.add(a, [i || "min", o || "max"], (a) => {
        const i = a.params.min;
        const o = a.params.max;
        i && o ? e(a, r, [i, o]) : i ? e(a, n, i) : o && e(a, t, o);
      });
    }),
    (m.addSingleVal = function (a, n, t) {
      return this.add(a, [n || "val"], (r) => {
        e(r, t || a, r.params[n]);
      });
    }),
    f.addMethod("__dummy__", (a, e, n) => !0),
    f.addMethod("regex", function (a, e, n) {
      let t;

      return (
        !!this.optional(e) ||
        ((t = new RegExp(n).exec(a)),
        t && 0 === t.index && t[0].length === a.length)
      );
    }),
    f.addMethod("nonalphamin", (a, e, n) => {
      let t;

      return n && ((t = a.match(/\W/g)), (t = t && t.length >= n)), t;
    }),
    f.methods.extension
      ? (m.addSingleVal("accept", "mimtype"),
        m.addSingleVal("extension", "extension"))
      : m.addSingleVal("extension", "extension", "accept"),
    m.addSingleVal("regex", "pattern"),
    m
      .addBool("creditcard")
      .addBool("date")
      .addBool("digits")
      .addBool("email")
      .addBool("number")
      .addBool("url"),
    m
      .addMinMax("length", "minlength", "maxlength", "rangelength")
      .addMinMax("range", "min", "max", "range"),
    m
      .addMinMax("minlength", "minlength")
      .addMinMax("maxlength", "minlength", "maxlength"),
    m.add("equalto", ["other"], (n) => {
      const o = r(n.element.name);
      const d = n.params.other;
      const s = i(d, o);
      const l = a(n.form)
        .find(":input")
        .filter(`[name='${t(s)}']`)[0];
      e(n, "equalTo", l);
    }),
    m.add("required", (a) => {
      ("INPUT" === a.element.tagName.toUpperCase() &&
        "CHECKBOX" === a.element.type.toUpperCase()) ||
        e(a, "required", !0);
    }),
    m.add("remote", ["url", "type", "additionalfields"], (o) => {
      const d = { url: o.params.url, type: o.params.type || "GET", data: {} };
      const s = r(o.element.name);
      a.each(n(o.params.additionalfields || o.element.name), (e, n) => {
        const r = i(n, s);
        d.data[r] = () => {
          const e = a(o.form)
            .find(":input")
            .filter(`[name='${t(r)}']`);

          return e.is(":checkbox")
            ? e.filter(":checked").val() || e.filter(":hidden").val() || ""
            : e.is(":radio")
              ? e.filter(":checked").val() || ""
              : e.val();
        };
      }),
        e(o, "remote", d);
    }),
    m.add("password", ["min", "nonalphamin", "regex"], (a) => {
      a.params.min && e(a, "minlength", a.params.min),
        a.params.nonalphamin && e(a, "nonalphamin", a.params.nonalphamin),
        a.params.regex && e(a, "regex", a.params.regex);
    }),
    m.add("fileextensions", ["extensions"], (a) => {
      e(a, "extension", a.params.extensions);
    }),
    a(() => {
      f.unobtrusive.parse(document);
    }),
    f.unobtrusive
  );
});
